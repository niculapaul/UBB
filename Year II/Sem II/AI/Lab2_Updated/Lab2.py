import numpy
from copy import deepcopy

'''
The conditions of this latin square resemble the n queens problem.
'''


class State:
    def __init__(self, matrix, level):
        self.matrix = matrix
        self.n = len(matrix)
        # This field is meant to help with keeping track of the number of queens that are already placed on the table
        self.level = level

    def isValid(self):
        columns = [[] for _ in range(self.n)]
        rows = [[] for _ in range(self.n)]
        forwardDiagonals = [[] for _ in range(self.n * 2 - 1)]
        backwardDiagonals = [[] for _ in range(self.n * 2 - 1)]

        for x in range(self.n):
            for y in range(self.n):
                columns[x].append(self.matrix[y][x])
                rows[y].append(self.matrix[y][x])
                forwardDiagonals[x + y].append(self.matrix[y][x])
                backwardDiagonals[x - y + self.n - 1].append(self.matrix[y][x])

        # check rows
        for row in rows:
            if numpy.count_nonzero(row) > 1:
                return False

        # check columns
        for column in columns:
            if numpy.count_nonzero(column) > 1:
                return False

        # check diagonals
        for diagonal in forwardDiagonals:
            if numpy.count_nonzero(diagonal) > 1:
                return False

        for diagonal in backwardDiagonals:
            if numpy.count_nonzero(diagonal) > 1:
                return False

        return True

    def getRemainingValidPositions(self):
        copyMatrix = deepcopy(self.matrix)

        for i in range(self.n):
            for j in range(self.n):
                if copyMatrix[i][j] == 1:
                    # Marking the line and column
                    for k in range(self.n):
                        if copyMatrix[k][j] == 0:
                            copyMatrix[k][j] = 2
                        if copyMatrix[i][k] == 0:
                            copyMatrix[i][k] = 2

                    # Marking the diagonals
                    indexSum = i + j
                    for i2 in range(self.n):
                        j2 = indexSum - i2
                        if 0 <= j2 < self.n and copyMatrix[i2][j2] == 0:
                            copyMatrix[i2][j2] = 2

                    indexDiff = i - j
                    for i2 in range(self.n):
                        j2 = i2 - indexDiff
                        if 0 <= j2 < self.n and copyMatrix[i2][j2] == 0:
                            copyMatrix[i2][j2] = 2

        # Counting unmarked positions
        count = 0
        for line in copyMatrix:
            count += self.n - numpy.count_nonzero(line)
        return count

    def generateNextStates(self):
        # The idea here is that each new state is generated by placing each new "queen" on every possible position on the next new line, therefore applying some of the problem restrictions directly "on the go"
        # Another possibility could have been just adding a new queen on every possible position on the whole table, I guess, and "ignore" the restrictions when building the tree, but that seems extremely inefficient

        # When we reach a leaf, we stop generating
        if self.level == self.n:
            return

        states = []
        for i in range(self.n):
            child = deepcopy(self.matrix)
            child[self.level][i] = 1
            state = State(child, self.level + 1)
            states.append(state)

        return states

    def printState(self):
        s = ""
        for row in self.matrix:
            for piece in row:
                s += str(piece) + " "
            s += "\n"
        print(s)


class Problem:
    def __init__(self, state):
        self.initialState = state
        # We don't know how the state we want to reach looks like, so it stays like this for now
        self.finalState = None

    @staticmethod
    def expand(state):
        return state.generateNextStates()

    def heuristic(self, state):
        # An idea here for comparing states would be looking for the number of "unattacked" squares for each configuration and see which one provides the most spaces that are not attacked by a queen
        # However, I believe the issue appears in the greedy algorithm, because it seems impossible to pick the best position to put the first queen
        return state.getRemainingValidPositions()


class Controller:
    def __init__(self):
        self.problem = None

    def setProblem(self, problem):
        self.problem = problem

    def dfs(self):
        path = []
        stack = [self.problem.initialState]
        while len(stack) > 0:
            currentState = stack.pop()
            path.append(currentState)

            if currentState.level == currentState.n:
                print("PATH:")
                for elem in path:
                    elem.printState()
                print("Solution found")
                return

            nextStates = self.problem.expand(currentState)
            validStates = []
            for state in nextStates:
                if state.isValid():
                    validStates.append(state)

            # For efficiency reasons, I add to the stack only the next states that are valid, instead of checking only the leaves
            for state in reversed(validStates):
                stack.append(state)

        print("PATH:")
        for elem in path:
            elem.printState()
        print("Solution not found")
        return

    def greedy(self):
        path = []
        stack = [self.problem.initialState]
        while len(stack) > 0:
            currentState = stack.pop()
            path.append(currentState)

            if currentState.level == currentState.n:
                print("Solution found")
                print("PATH:")
                for elem in path:
                    elem.printState()
                return

            nextStates = self.problem.expand(currentState)
            validStates = []
            for state in nextStates:
                if state.isValid():
                    validStates.append(state)

            if len(validStates) > 0:
                # Here, I look only for the best next state
                bestState = validStates[0]
                bestValue = self.problem.heuristic(bestState)
                for state in validStates:
                    currentValue = self.problem.heuristic(state)
                    if currentValue > bestValue:
                        bestState = state
                        bestValue = currentValue

                stack.append(bestState)
        print("Solution not found")
        print("PATH:")
        for elem in path:
            elem.printState()
        return

    def bestFS(self):
        path = []
        stack = [self.problem.initialState]
        while len(stack) > 0:
            currentState = stack.pop()
            path.append(currentState)

            if currentState.level == currentState.n:
                print("PATH:")
                for elem in path:
                    elem.printState()
                return

            nextStates = self.problem.expand(currentState)
            validStates = []
            for state in nextStates:
                if state.isValid():
                    validStates.append(state)


            validStates.sort(key=lambda x: self.problem.heuristic(x))
            stack += validStates

        print("PATH:")
        for elem in path:
            elem.printState()
        return


class UI:
    def __init__(self):
        self.controller = Controller()

    def showMenu(self):
        print("Choose method")
        print("1. DFS")
        print("2. Greedy")
        print("3. BestFS")

    def run(self):
        n = int(input("Board size: "))
        board = [[0 for col in range(n)] for row in range(n)]
        initialState = State(board, 0)
        problem = Problem(initialState)
        self.controller.setProblem(problem)
        self.showMenu()

        method = int(input())
        if method == 1:
            self.controller.dfs()
        elif method == 2:
            self.controller.greedy()
        elif method == 3:
            self.controller.bestFS()


ui = UI()
ui.run()
